/**
 * Types, constants, and utility functions for the quality rating engine.
 * Extracted to keep quality-rater.ts focused on core logic.
 * See S4.T.3 â€” Agent Hierarchy (Multi-Agent Rating).
 */

import type BetterSqlite3 from 'better-sqlite3';
import type { LLMProvider, ModelTier } from '../types/index.js';

// === Constants ===

/** Minimum quality score below which a retry is warranted. */
export const RETRY_THRESHOLD = 0.4;

/** Maximum number of quality-driven retries per task. */
export const MAX_RETRIES = 1;

/** Maximum tokens to allocate for the rating LLM call. */
export const RATING_MAX_TOKENS = 256;

// === Interfaces ===

/** Dependencies injected into the quality rater. */
export interface QualityRaterDeps {
  /** Database connection for persisting ratings. */
  db: BetterSqlite3.Database;
  /** A medium-tier LLM provider used to rate outputs. */
  provider: LLMProvider;
  /** Maximum USD budget available for rating calls. */
  costBudgetUsd: number;
}

/** Input data required to rate a task's output. */
export interface RateInput {
  /** Unique identifier for the task being rated. */
  taskId: string;
  /** The original user message that triggered the task. */
  userMessage: string;
  /** The assistant's response text to evaluate. */
  assistantResponse: string;
  /** The model that produced the response. */
  model: string;
  /** The tier of the model that produced the response. */
  tier: ModelTier;
}

/** Result of a quality rating evaluation. */
export interface RatingResult {
  /** Quality score between 0 and 1. */
  score: number;
  /** Brief textual feedback explaining the score. */
  feedback: string;
  /** The model used to perform the rating. */
  ratingModel: string;
  /** Cost of the rating call in USD. */
  costUsd: number;
  /** Number of input tokens consumed by the rating call. */
  inputTokens: number;
  /** Number of output tokens generated by the rating call. */
  outputTokens: number;
}

/** Public interface of the quality rater. */
export interface QualityRater {
  /**
   * Determine whether a given model tier and model should be rated.
   * @param tier - The model tier of the completion.
   * @param model - The model identifier.
   * @returns True if the output should undergo quality rating.
   */
  shouldRate(tier: ModelTier, model: string): boolean;

  /**
   * Rate the quality of an assistant response.
   * @param input - The rating input containing task context and response.
   * @returns A RatingResult with score, feedback, and cost data.
   */
  rateOutput(input: RateInput): Promise<RatingResult>;

  /**
   * Determine whether a task should be retried based on its rating.
   * @param rating - The rating result to evaluate.
   * @param retryCount - Number of retries already attempted.
   * @returns True if the task should be retried with a better model.
   */
  shouldRetry(rating: RatingResult, retryCount: number): boolean;
}

/** Result of a post-task quality check. */
export interface QualityCheckResult {
  /** Whether the output was actually rated. */
  rated: boolean;
  /** Quality score if rated. */
  score?: number;
  /** Whether the task should be retried with a better model. */
  shouldRetry: boolean;
  /** Brief feedback if rated. */
  feedback?: string;
}

// === Utility Functions ===

/**
 * Build the prompt sent to the rating model.
 * @param userMessage - The original user message.
 * @param assistantResponse - The assistant's response to evaluate.
 * @returns The formatted rating prompt string.
 */
export function buildRatingPrompt(userMessage: string, assistantResponse: string): string {
  return `Rate this AI assistant's response quality from 0 to 1. Reply with JSON: {"score": <0-1>, "feedback": "<brief reason>"}\n\nUser asked: ${userMessage}\n\nAssistant replied: ${assistantResponse}`;
}

/**
 * Parse the rating model's JSON response into a score and feedback.
 * Handles malformed output by defaulting to score 0.5.
 * @param responseText - The raw text response from the rating model.
 * @returns An object with score (0-1) and feedback string.
 */
export function parseRatingResponse(responseText: string): { score: number; feedback: string } {
  try {
    // Try to extract JSON from the response (may contain surrounding text)
    const jsonMatch = responseText.match(/\{[^}]*"score"\s*:\s*[\d.]+[^}]*\}/);
    const jsonStr = jsonMatch ? jsonMatch[0] : responseText;
    const parsed: unknown = JSON.parse(jsonStr);

    if (
      typeof parsed === 'object' &&
      parsed !== null &&
      'score' in parsed &&
      typeof (parsed as Record<string, unknown>).score === 'number'
    ) {
      const record = parsed as Record<string, unknown>;
      const rawScore = record.score as number;
      const clampedScore = Math.max(0, Math.min(1, rawScore));
      const feedback = typeof record.feedback === 'string' ? record.feedback : 'No feedback provided';
      return { score: clampedScore, feedback };
    }

    return { score: 0.5, feedback: 'Could not parse rating response structure' };
  } catch {
    return { score: 0.5, feedback: 'Malformed rating response' };
  }
}
